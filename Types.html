<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>基本类型 - lua-note</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/pagetoc.css">
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Getting-Started.html"><strong aria-hidden="true">1.</strong> 入门</a></li><li class="chapter-item expanded "><a href="Types.html" class="active"><strong aria-hidden="true">2.</strong> 基本类型</a></li><li class="chapter-item expanded "><a href="IO.html"><strong aria-hidden="true">3.</strong> I/O 功能</a></li><li class="chapter-item expanded "><a href="Syntax.html"><strong aria-hidden="true">4.</strong> 语法细节</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">lua-note</h1>

                    <div class="right-buttons">
                        <a href="https://github.com/zjp-CN/lua-note" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>

                        <h1 id="基本类型"><a class="header" href="#基本类型">基本类型</a></h1>
<p>lua 有八种基本类型，而且 <code>nil</code>、<code>Boolean</code>、<code>userdata</code>
类型在 <a href="./Getting-Started.html#%E7%B1%BB%E5%9E%8B">入门#类型</a> 部分介绍完了。</p>
<p>此部分介绍其余几种。</p>
<h2 id="numbers"><a class="header" href="#numbers"><code>numbers</code></a></h2>
<p><code>numbers</code> 类型分为两类<sup class="footnote-reference"><a href="#numbers">1</a></sup>：</p>
<ol>
<li>整数 (integers)：64 位整数。</li>
<li>浮点型 (floats)：双精度浮点。</li>
</ol>
<div class="footnote-definition" id="numbers"><sup class="footnote-definition-label">1</sup>
<p>这个分类是 lua 5.3 之后的情况（在某些平台上，你可以编译成 32 位整数和单精度浮点），
lua 5.2 之前的版本的 numbers 只有单精度浮点型。可以称整数和浮点数为 <code>numbers</code> 的子类型 (subtype)。</p>
</div>
<h3 id="表示方法"><a class="header" href="#表示方法">表示方法</a></h3>
<ol>
<li>十进制整数：0、1、-1 等等。</li>
<li>带小数点的浮点数：<code>0.</code>、<code>1.2</code>、<code>-1.3</code> 等等。</li>
<li>科学计数法（<code>e</code> 或 <code>E</code>，背后是浮点数）：<code>1E2</code>、<code>1E+2</code>、<code>1E-2</code>、<code>1e2</code>、<code>1e+2</code>、<code>1e-2</code> 等等。</li>
<li>十六进制整数（<code>0x</code> 或 <code>0X</code> 开头）：<code>0xff == 16*15+15 --&gt; 255</code>、<code>0x1A3 == 16^2*1+16*10+3 --&gt; 419</code> 等等。</li>
<li>十六进制浮点数（<code>0x</code> 或 
<code>0X</code> 开头，带小数位）：<code>0x0.2 == 2/16 --&gt; 0.125</code>、<code>0xa.25 == 10+2/16^1+5/16^2 --&gt; 10.14453125</code> 等等。</li>
<li>十六进制+二进制的浮点数（<code>0x</code> 或 <code>0X</code> 开头，带 <code>p</code> 或 <code>P</code>，其中 <code>p</code> 表示 
<code>2.^</code><sup class="footnote-reference"><a href="#p">2</a></sup>）：<code>0x1p1 == 1*2.^1 --&gt; 2.0</code>、<code>0xap-1 == 10*2.^-1 --&gt; 5.0</code> 等等。</li>
<li>十六进制浮点数（结合小数位和二进制）：<code>0xa.bp+3 == (10+11/16)*2.^3 --&gt; 85.5</code> 等等。</li>
</ol>
<p>但是整数和浮点数在 lua 中都使用 <code>numbers</code> 类型，因为两者往往相互转化。</p>
<p>从而，当浮点数可以转化成整数时，两者相等：<code>0. == 0 --&gt; true</code>、<code>1e2 == 100 --&gt; true</code>。</p>
<p>当你真的需要区分这两类 <code>numbers</code>，则使用 <code>math.type</code> 函数。</p>
<p>使用 <code>string.format</code> 和 <code>%a</code> 将一个数字转化为十六进制浮点数表示：</p>
<pre><code class="language-lua">string.format(&quot;%a&quot;, 419) --&gt; 0x1.a3p+8 即 0x1A3
string.format(&quot;%a&quot;, 0.1) --&gt; 0x1.999999999999ap-4
</code></pre>
<p>虽然这种形式不是很好阅读，但是它保存了任意浮点数的所有精度，而且比基于十进制的转化快。</p>
<div class="footnote-definition" id="p"><sup class="footnote-definition-label">2</sup>
<p>这从 lua 5.2 之后才被引进。</p>
</div>
<h3 id="算术运算符"><a class="header" href="#算术运算符">算术运算符</a></h3>
<table><thead><tr><th>算术运算符</th><th>计算结果的类型</th></tr></thead><tbody>
<tr><td><code>+</code>、<code>-</code>、<code>*</code>、<code>//</code>、<code>%</code></td><td>当两个运算对象都是整数时，结果为整数；否则为浮点数</td></tr>
<tr><td><code>/</code>、<code>^</code></td><td>浮点数（因为两个整数相除或幂的结果不一定是整数）</td></tr>
<tr><td><code>&gt;</code>、<code>&lt;</code>、<code>==</code>、<code>~=</code>、<code>&gt;=</code>、<code>&lt;=</code></td><td><code>Boolean</code>（整数可以和浮点数比较，但同一子类型比较效率更高）</td></tr>
</tbody></table>
<ul>
<li><code>//</code> (floor division) 的结果总是把商的结果向负半轴方向取整，比如 
<code>3 // 2 --&gt; 1</code>、<code>-9 // 2 --&gt; -5.0</code>。此运算符从 lua 5.3 之后被引入。类似于
<code>math.floor(-9/2)</code> 但 <code>//</code> 的类型可能为浮点数。</li>
<li><code>%</code> (modulo) 具有以下性质： <code>a % b == a - ((a // b) * b)</code>。其结果总是与第二个运算对象正负号相同。当
<code>b</code> 大于 1 时，其结果总是在 <code>[0, b-1]</code> 范围内。</li>
</ul>
<h3 id="数学库运算"><a class="header" href="#数学库运算">数学库运算</a></h3>
<p>lua 5.3 的<a href="http://www.lua.org/manual/5.3/manual.html#6.7">数学函数 API</a>。</p>
<table><thead><tr><th>函数</th><th>返回值</th></tr></thead><tbody>
<tr><td>math.random</td><td>无参数时为 <code>[0,1)</code> 内的浮点数；一个正整数时为 <code>[1,n]</code> 内的整数；两个正整数 m 和 n 时为 <code>[m, n]</code> 内的整数</td></tr>
<tr><td>math.floor</td><td>向负无穷方向取整；当参数为整数时，直接返回整数</td></tr>
<tr><td>math.ceil</td><td>向正无穷方向取整；当参数为整数时，直接返回整数</td></tr>
<tr><td>math.modf</td><td>向 0 方向取整；当参数为整数时，直接返回整数；此外，它还返回小数部分，如 <code>math.modf(-3.3) --&gt; -3 -0.3</code></td></tr>
</tbody></table>
<ul>
<li>
<p>对 <code>x</code> 四舍五入法取整：</p>
<ol>
<li>方法一：<code>math.floor(x + 0.5)</code>。当数字足够大时（比如 <code>2^52 + 1</code>），这个方法会出现问题。</li>
</ol>
<pre><code class="language-lua">-- 对 1 四舍五入取整为 1
math.floor(1)    --&gt; 1
math.floor(1+.5) --&gt; 1
-- 对 2^52 + 1 四舍五入取整应该为自己
2^52+1 == 4503599627370497 --&gt; true
math.floor(2^52+1)   --&gt; 4503599627370497
math.floor(2^52+1.5) --&gt; 4503599627370498 因为双精度无法正确表示 2^52+1.5
</code></pre>
<ol start="2">
<li>方法二：对方法一进行完善，当参数为整数时，直接返回整数，不 <code>+.5</code></li>
</ol>
<pre><code class="language-lua">function round (x)
  local f = math.floor(x)
  if x == f then return f
  else return math.floor(x + 0.5)
  end
end
</code></pre>
</li>
<li>
<p>对 <code>x</code> 进行双数取整 (unbiased rounding、round-to-even)：</p>
</li>
</ul>
<pre><code class="language-lua">function round (x)
  local f = math.floor(x)
  if (x == f) or (x % 2.0 == 0.5) then
    return f
  else
    return math.floor(x + 0.5)
  end
end
</code></pre>
<h3 id="范围和精度"><a class="header" href="#范围和精度">范围和精度</a></h3>
<p>详细论述见 <code>Programming in Lua#Representation Limits</code> 部分。一些要点：</p>
<table><thead><tr><th>number</th><th>范围或精度（64 位）</th></tr></thead><tbody>
<tr><td>整数</td><td>-2^63 ~ 2^63-1，大约为 -10^19 ~ 10^19</td></tr>
<tr><td>浮点数</td><td>大约 -10^308 ~ 10^308，精确到小数后 16 位，能精确表示的整数范围 [-2^53, 2^53]</td></tr>
</tbody></table>
<p>一些极端例子：</p>
<pre><code class="language-lua">math.maxinteger    --&gt;  9223372036854775807
0x7fffffffffffffff --&gt;  9223372036854775807
math.mininteger    --&gt; -9223372036854775808
0x8000000000000000 --&gt; -9223372036854775808

math.maxinteger + 1 == math.mininteger   --&gt; true
math.mininteger - 1 == math.maxinteger   --&gt; true
-math.mininteger == math.mininteger      --&gt; true
math.mininteger // -1 == math.mininteger --&gt; true

math.maxinteger + 2   --&gt; -9223372036854775807
math.maxinteger + 2.0 --&gt; 9.2233720368548e+18
math.maxinteger + 2.0 == math.maxinteger + 1.0 --&gt; true
</code></pre>
<h3 id="浮点和整数相互转换"><a class="header" href="#浮点和整数相互转换">浮点和整数相互转换</a></h3>
<ul>
<li>整数转成浮点：
<ul>
<li>让整数与 <code>0.0</code> 相加。注意：此方法针对超过 2^53 的整数，会导致相加的结果以确定的双精度浮点数的形式表示，
从而 <code>9007199254740993 + 0.0 == 9007199254740993 --&gt; false</code>。</li>
</ul>
</li>
<li>浮点转成整数（只在浮点数能表示成整数时）：
<ul>
<li>让整数与 <code>0</code> 或运算。如 <code>2^1 | 0 --&gt; 2</code>。注意：这在无法转换时出现错误。</li>
<li>使用 <code>math.tointeger</code> 函数。当无法转换时，返回 <code>nil</code>。如
<code>math.tointeger(-1.0) --&gt; -1</code>、<code>math.tointeger(2^64) --&gt; nil</code></li>
</ul>
</li>
</ul>
<h2 id="string"><a class="header" href="#string"><code>string</code></a></h2>
<h3 id="基础要点"><a class="header" href="#基础要点">基础要点</a></h3>
<ul>
<li>lua 中的 <code>string</code> 是字节序列，存储任何二进制数据，不局限于文本、编码。</li>
<li><code>string</code> 是不可变的值 (immutable values)，修改值就是创建新的 <code>string</code>。</li>
<li>lua 的所有对象是自动内存管理的，包括 <code>string</code> —— 无需担心分配和重新分配的问题。</li>
<li>基本操作（字节操作，不局限于字符编码）：
<ul>
<li><strong>字节</strong>长度 <code>#</code>：如 <code>#&quot;a&quot; --&gt; 1</code>、<code>b = '中'; print(#b) --&gt; 3</code></li>
<li>拼接 <code>..</code>：如 <code>&quot;Hello &quot; .. &quot;World&quot; --&gt; Hello World</code>、<code>a = &quot;a&quot;; print(a..0) --&gt; a0</code>、<code>'1'..3 --&gt; 13</code>、<code>3 .. 5 --&gt; 35</code></li>
</ul>
</li>
<li>字面字符串 (literal strings)：
<ul>
<li>使用单引号 <code>'</code> 或双引号 <code>&quot;</code>：<code>'a'</code>、<code>&quot;B&quot;</code>、<code>'&quot;a&quot;'</code>、<code>&quot;'B'&quot;</code>、<code>'&quot;a&quot;' == &quot;\&quot;a\&quot;&quot; --&gt; true</code><br />
两种写法是等价的，区别在于使用一种引号的字面值无需转义另一种引号。</li>
<li>支持的转义符号：<code>\a</code>、<code>\b</code>、<code>\f</code>、<code>\n</code>、<code>\r</code>、<code>\t</code>、<code>\v</code>、<code>\\</code>、<code>\&quot;</code>、<code>\'</code></li>
<li>转义序列：
<ul>
<li><code>\ddd</code> 三位十进制数：如 <code>&quot;\065&quot; --&gt; A</code>、<code>&quot;\122&quot; --&gt; z</code></li>
<li><code>\xhh</code> 两位十六进制数：如 <code>&quot;\x41&quot; --&gt; A</code>、<code>&quot;\x7A&quot; --&gt; z</code></li>
<li><code>\u{h... h}</code> 表示 UTF-8 字符：如 <code>&quot;\u{4E2D}&quot; --&gt; 中</code></li>
</ul>
</li>
<li>忽略连续空白字符 (white-space characters) <code>\z</code>：空白字符包括 <code>' '</code>、<code>'\r'</code> <code>'\x08'</code> 
之类的符号，但不包括 <code>\n</code>。即 <code>&quot;\z\r \na&quot; --&gt; 输出等价于 &quot;\na&quot;</code>。</li>
<li>多行文本（这两个功能对<a href="Getting-Started.html#%E6%B3%A8%E9%87%8A%E7%AC%A6%E5%8F%B7">注释</a>也生效）：
<ul>
<li>
<p>使用 <code>[[</code> 和 <code>]]</code>：</p>
<pre><code class="language-lua">page = [[
    multi lines [1]
]]
</code></pre>
<p>会识别为</p>
<pre><code class="language-text">    multi lines [1]

</code></pre>
</li>
<li>
<p>使用 <code>[=[</code> 和 <code>]=]</code>，其中的等号数量任意，但两边的等号数量必须相等。
上面的方法无法输入 <code>[[</code> 或 <code>]]</code>（因为它们是开始和结束的符号），所以添加等号来增强标识。</p>
<pre><code>page = [=[
[[[[[[[[[[[[[[[]]]]]]]]]]]]]]=]
</code></pre>
<p>这段代码可以连续输入任意多的括号，以及中间携带任意多等号的双括号（一个等号除外）。 
原因相同，lua 会按照开始和结束的符号确定长文本，唯一的限制是文本不能包含开始或结束的符号。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="强制转换"><a class="header" href="#强制转换">强制转换</a></h3>
<ul>
<li>
<p>在算数操作符和预计传入数字的地方，<code>string</code> 会尝试转化成 <code>number</code>。</p>
</li>
<li>
<p>同理，在预计需要字符串的地方，<code>number</code> 会转化成 <code>string</code>。</p>
</li>
<li>
<p>注意，<code>1 .. 2</code> 的结果是 <code>&quot;12&quot;</code>，而且 <code>..</code> 前面为数字时，必须用空格隔开，因为 lua 会把 <code>.</code> 视为数字的一部分。</p>
</li>
<li>
<p>字符串和数字的算数操作中，字符串总是转成浮点型：如 <code>'1'+1 --&gt; 2.0</code>。</p>
</li>
<li>
<p>显式把字符串转成整数，使用 <code>tonumber</code> 函数。此函数：</p>
<ul>
<li>在一个参数时，接收任何<a href="#%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95">有效的数字表示</a>。</li>
<li>在两个参数时，第二个参数为 2 到 36 的进制方式，且输入的数字不是该进制的正确表示，那么返回 <code>nil</code>。</li>
</ul>
<pre><code class="language-lua">tonumber(&quot;0xa&quot;)        --&gt; 10
tonumber(&quot;100101&quot;, 10) --&gt; 100101
tonumber(&quot;100101&quot;, 2)  --&gt; 37
tonumber(&quot;fff&quot;, 16)    --&gt; 4095
tonumber(&quot;-ZZ&quot;, 36)    --&gt; -1295
tonumber(&quot;987&quot;, 8)     --&gt; nil 八进制不含 8 和 9
tonumber(&quot;0xa&quot;, 10)    --&gt; nil 十进制不含 a
</code></pre>
</li>
<li>
<p>显式把数字转化成字符串，使用 <code>tostring</code> 函数。如 
<code>tostring(0) --&gt; &quot;0&quot;</code>、<code>tostring(0xa) --&gt; 10</code>。这个转换总是成功的，但指定数字的呈现格式，须使用
<code>string.format</code>。</p>
</li>
<li>
<p>数字和字符串之间无法比较大小。字符串与字符串之间按照字母表顺序比较大小 (alphabetical order)。如 
<code>1&gt;&quot;1&quot; --&gt; 错误</code>、<code>&quot;1&quot; &lt; &quot;2&quot; --&gt; true</code>、<code>'12' &lt; 'a' --&gt; true</code></p>
</li>
<li>
<p>根据 <a href="Getting-Started.html#boolean"><code>Boolean</code></a> 的运算规则，由于数字和字符串类型不同，当比较相等时，总为
<code>false</code>：如 <code>&quot;1&quot; == 1 --&gt; false</code>、<code>'0' ~= 0 --&gt; true</code>。</p>
</li>
</ul>
<h3 id="标准库函数"><a class="header" href="#标准库函数">标准库函数</a></h3>
<p>在标准库之外，lua 在 <code>string</code> 方面只提供创建字面值、拼接、比较、获取字节长度的功能。</p>
<p>而标准库的 <code>string</code> 相关函数也只提供基础的功能且假设字符串是单字节的。lua 5.3 之后才引入处理 UTF-8 的功能（见下节）。</p>
<p>几乎所有返回 <code>string</code> 的函数都返回新 <code>string</code>，lua <strong>貌似</strong>没有切片（视图）的概念。</p>
<p>lua 的索引从 1 开始，而且允许负数索引：-1 表示倒数第一个字节，-2 表示倒数第二个字节，等等。索引区间一般为两边闭区间。</p>
<p>几乎所有的 <code>string.xx</code> 函数都可以写成 <code>s:xx</code> 的形式，其中 <code>s</code> 是变量名，如 <code>a = &quot;123&quot;; print(a:reverse()) --&gt; 321</code>。</p>
<table><thead><tr><th>函数名</th><th>功能（返回值）</th><th>附注</th></tr></thead><tbody>
<tr><td>string.len(s)</td><td>s 的字节长度</td><td>等价于 <code>#s</code></td></tr>
<tr><td>string.rep(s, n)</td><td>把 s 重复 n 次</td><td>如 <code>string.rep(&quot;a&quot;, 2^20)</code> 表示创建 1 MB 的 <code>a</code> 字符</td></tr>
<tr><td>string.reverse(s)</td><td>把 s 字节反转</td><td></td></tr>
<tr><td>string.lower(s)</td><td>转化成大写</td><td></td></tr>
<tr><td>string.upper(s)</td><td>转化成小写</td><td></td></tr>
<tr><td>string.sub(s, i, j)</td><td>获取 <code>[i, j]</code> 区间的字节</td><td>返回新 <code>string</code>；省略 <code>j</code> 表示 <code>[i, -1]</code></td></tr>
<tr><td>string.char(n1)</td><td>把数字转成对应的字符</td><td>支持多个数字，如 <code>string.char(97, 98, 99) --&gt; &quot;abc&quot;</code></td></tr>
<tr><td>string.byte(s, i, j)</td><td>把 <code>[i, j]</code> 区间的字节转成数字</td><td>省略 <code>j</code> 表示 <code>[i, i]</code>；省略 <code>i</code> 和 <code>j</code> 表示 <code>[1, 1]</code></td></tr>
<tr><td>string.format(..., s)</td><td>格式化字符串，参考 C 的 <code>printf</code></td><td>比如 <code>%d</code>、<code>%x</code>、<code>%f</code> 分别表示 十进制、十六进制、浮点</td></tr>
<tr><td>string.find(s, pattern)</td><td>查找模式，返回索引区间或 nil</td><td>如 <code>string.find(&quot;hello world&quot;, &quot;wor&quot;) --&gt; 7 9</code></td></tr>
<tr><td>string.gsub(s, pat, tar)</td><td>返回替换之后的字节和次数</td><td>如 <code>string.gsub(&quot;hello&quot;, &quot;l&quot;, &quot;.&quot;) --&gt; he..o 2</code></td></tr>
</tbody></table>
<h3 id="处理-utf-8"><a class="header" href="#处理-utf-8">处理 UTF-8</a></h3>
<p>UTF-8 的 <code>string</code> 适用于 <code>#</code> 和 <code>..</code> 操作，也适用于比较大小操作（按照 Unicode 代码点顺序），但不适用于假定为单字节操作的 
<code>string.xx</code> 函数。</p>
<p>以下 <code>utf8.xx</code> 函数仅被 lua 5.3 之后的版本支持，<code>string.xx</code> 函数不受 lua 5.3 影响。</p>
<table><thead><tr><th>函数名</th><th>功能（返回值）</th><th>附注</th></tr></thead><tbody>
<tr><td>utf8.len(s)</td><td>s 的字节长度</td><td>等价于 <code>#s</code></td></tr>
<tr><td>utf8.lower(s)</td><td>转化成大写</td><td></td></tr>
<tr><td>utf8.upper(s)</td><td>转化成小写</td><td></td></tr>
<tr><td>utf8.offset(s,n)</td><td>获取第 n 个 Unicode 的字节索引</td><td>n 可以为负整数，表示倒数第几个字符</td></tr>
<tr><td>utf8.char(n1)</td><td>把数字转成对应的字符</td><td>支持多个数字，如 <code>string.char(97, 98, 99) --&gt; &quot;abc&quot;</code></td></tr>
<tr><td>utf8.codepoint(s, i, j)</td><td>把 <code>[i, j]</code> 字节区间内容的转成代码点</td><td>类似于 <code>string.byte</code></td></tr>
<tr><td>utf8.codes(s)</td><td>返回 UTF-8 字符迭代器</td><td>如 <code>for index, c in utf8.codes(s)</code> c 为字节的数字表示</td></tr>
<tr><td>string.rep(s, n)</td><td>把 s 重复 n 次</td><td></td></tr>
<tr><td>string.sub(s, i, j)</td><td>获取 <code>[i, j]</code> 区间的字节</td><td>如 <code>string.sub(s, utf8.offset(s, -2))</code> 获取最后两个字符</td></tr>
<tr><td>string.format(..., s)</td><td>格式化字符串，参考 C 的 <code>printf</code></td><td>无法使用 <code>%c</code></td></tr>
<tr><td>string.find(s, pattern)</td><td>查找模式，返回索引区间或 nil</td><td></td></tr>
<tr><td>string.gsub(s, pat, tar)</td><td>返回替换之后的字节和次数</td><td></td></tr>
</tbody></table>
<p>UTF-8 编码让每个 Unicode 字符的字节数长度不固定。它让 ASCII 范围内的字符保持单字节，让大部分中文字符为 3 字节长度。具体来说：</p>
<ul>
<li>小于 128 的单个字节与 ASCII 相同；</li>
<li>非单字节的首个字节范围为 [194, 244]，其后的字节位于 [128, 191]；</li>
<li>两字节字符的首个字节范围为 [194, 223]</li>
<li>三字节字符的首个字节范围为 [224, 239]</li>
<li>四字节字符的首个字节范围为 [240, 244]</li>
</ul>
<p>lua 自身不提供复杂的 <code>string</code> 处理。不同版本对字符串的处理也不同，参考 
<a href="https://www.lua.org/manual/5.1/manual.html#5.4">5.1</a>、<a href="https://www.lua.org/manual/5.3/manual.html#6.4">5.3</a> 手册。</p>
<h2 id="table"><a class="header" href="#table"><code>table</code></a></h2>
<h3 id="基础要点-1"><a class="header" href="#基础要点-1">基础要点</a></h3>
<ul>
<li><code>table</code> 是 lua 最主要（唯一）的数据结构机制，可以作为包、模块、数组使用：比如 <code>math.sin</code> 是一个 <code>table</code>。</li>
<li><code>table</code> 在 lua 中既不是值 (value)，也不是变量 (variable)，而是对象 (object)。</li>
<li><code>table</code> 通过构造表达式 (constructor expression) <code>{}</code> 创建（初始化）一个表：
<ul>
<li><code>a = {}</code> 创建一个空表</li>
<li><code>a = {x = 0, y = 0}</code> 等价于 <code>a = {[&quot;x&quot;] = 0, [&quot;y&quot;] = 0}</code> 等价于 <code>a = {}; a.x = 0; a.y = 0;</code></li>
<li><code>a = {&quot;1&quot;, 2}</code> 等价于 <code>a = {[2] = &quot;1&quot;, [2] = 2}</code> 等价于 <code>a = {}; a[1] = &quot;1&quot;; a[2] = 2;</code></li>
<li>最后的逗号是可选的：<code>a = {0}</code> 等价于 <code>a = {0,}</code> </li>
<li>所有 <code>,</code> 都可以换成 <code>;</code>，两种符号没有区别：<code>a = {1, 2}</code> 等价于 <code>a = {1; 2}</code></li>
<li>带字段的语法可以和无字段的语法并存：如 <code>a = {1, b = 2}</code>，则 <code>a[1] --&gt; 1; a.b --&gt;2</code></li>
<li>表可以嵌套表：比如 <code>a = {1}; b = {a}</code>，则 <code>b[1][1] --&gt; 1</code> 又比如 <code>a = {x = {y = 1}}</code> 则 <code>a.x.y --&gt; 1</code></li>
<li>表可以存放函数：如 <code>a = {f = math.floor}; a.f(0.5) --&gt; 0</code></li>
</ul>
</li>
<li><code>table</code> 总是匿名的，变量并不拥有 <code>table</code>：<code>a = {}; b = a</code> 意味着 a 与 b 指向同一个表，通过任何一个指针修改都会同步修改。</li>
<li>可以给变量赋值为 <code>nil</code> 来减少 <code>table</code> 的引用，当一个表不再有引用时，垃圾回收器最终会删除表，重新使用该块内存：
<ul>
<li><code>a = {1}; a = nil</code> 让 <code>{1}</code> 在只有一个引用的情况下变成了无引用；</li>
<li><code>a = {1}; b = {a}; a = nil</code> 让 <code>{1}</code> 在两个引用的情况下减少一个引用，<code>b[1][1]</code> 依然有效。</li>
</ul>
</li>
<li>lua 程序管理 <code>table</code> 的指针（引用），但不隐式复制出新的 <code>table</code>。</li>
<li><code>table</code> 使用索引存储数据，语法为 <code>table[index]</code>：
<ul>
<li>索引的类型并不唯一，可以是字符串、数字等；</li>
<li>无字段初始化的表的索引从 1 开始：如 <code>a = {&quot;1&quot;, 2}</code> 使用 <code>a[1] --&gt; &quot;1&quot;</code>、<code>a[2] --&gt; 2</code> 的方式获取数据；</li>
<li>索引未初始化的部分时，返回 <code>nil</code>；</li>
<li>通过赋值为 <code>nil</code> 来删除表的索引（或者叫做字段、键）：如 <code>a = {1}; a[1] = nil</code>；</li>
<li>索引语法糖：<strong><code>a.name</code> 是 <code>a[&quot;name&quot;]</code> 的语法糖</strong>，而不是 <code>a[name]</code> 的语法糖；</li>
<li>不支持 <code>a.1</code> 之类的语法糖来进行 <code>a[&quot;1&quot;]</code> 操作；</li>
<li>由于整数和浮点数都是 <code>number</code> 类型，所以 <code>a[0]</code> 和 <code>a[0.]</code> 是一样的；</li>
<li>索引不同的类型，得到不同的数据：<code>a[0]</code> 和 <code>a[&quot;0&quot;]</code> 是不一样的；</li>
<li>不能在 <code>nil</code> 索引上存储数据： <code>a[nil] = 1</code> 或者 <code>b = nil; a[b] = 1</code> 是不允许的；</li>
</ul>
</li>
</ul>
<h3 id="数组列表序列操作"><a class="header" href="#数组列表序列操作">数组、列表、序列操作</a></h3>
<ul>
<li><code>table</code> 无法声明长度（大小）。</li>
<li>使用 <code>#</code> 符号获取 <code>table</code> 的“长度”。长度在 <code>table</code> 里是一个不好定义的事物。出于历史原因，可以使用 <code>n</code> 字段存放长度信息。</li>
<li>带正整数索引的 <code>table</code> 被称为数组 (array) 或者列表 (list)。</li>
<li>如果一个 <code>table</code> 不仅带正整数索引，还带其他类型的索引，那么带正整数索引的那部分被称为列表。</li>
<li>由于 <code>table</code> 可以有不连续的键（索引），比如 <code>d = {1, 2}; d[5] = 5</code> 在 [3, 4] 的值为 <code>nil</code>，此时这种中间有
<code>nil</code> 元素的 <code>table</code> 被认为有一个洞 (hole)。</li>
<li>在 lua 看来，值为 <code>nil</code> 的字段和未初始化的字段没有区别：对于 <code>a = {1, nil, 3}</code>，<code>a[2]</code> 和 <code>a[4]</code> 一样。</li>
</ul>
<p>序列 (sequence)：</p>
<ul>
<li>定义：对于正整数 n，如果表的 <code>{1, ..., n}</code> 索引存储的值都不是 <code>nil</code>，那么称表的 <code>{1, ..., n}</code> 的部分叫做序列。</li>
<li>无 <code>{1, ..., n}</code> 数值索引的表，被称为长度为 0 的序列</li>
<li>比如 <code>a = {1, 2, 3}</code>，<code>a</code> 是一个长度为 3 的序列（<code>#a == 3</code>）</li>
</ul>
<p>对于有洞的列表，其长度有时不会是你想要的：</p>
<ul>
<li>比如上面定义的 <code>d</code>，有 <code>#d == 2</code>，而 <code>#{1, 2, nil, nil, 5} == 5</code>。</li>
<li>甚至有 <code>#{1, 2, nil, nil} == #{1, 2}</code>：在列表最末端的那些 <code>nil</code>，lua 不会考虑它们的长度。</li>
<li>大多数情况下，lua 遇到的列表为序列，此时使用获取的长度是安全的，但遇到有洞的列表，其长度并不可靠。</li>
<li>如果你真的需要处理有洞的列表，应该把长度显式地存储在某个地方。</li>
</ul>
<h3 id="遍历-table"><a class="header" href="#遍历-table">遍历 <code>table</code></a></h3>
<ol>
<li>使用 <code>pairs</code> 迭代器遍历 <code>table</code> 的所有键值对：</li>
</ol>
<pre><code class="language-lua">t = {10, print, x = 12, k = &quot;hi&quot;}
for k, v in pairs(t) do
print(k, v)
end
--&gt; 1 10
--&gt; k hi
--&gt; 2 function: 0x420610
--&gt; x 12
</code></pre>
<p>遍历的顺序是未定义的，每次运行都可能顺序不同。但可以确定的是，它会把所有键值对遍历一次。</p>
<ol start="2">
<li>使用长度和 <code>for</code> 遍历序列部分：</li>
</ol>
<pre><code class="language-lua">t = {10, print, nil, &quot;4&quot;, x = 12, k = &quot;hi&quot;}
for k = 1, #t do
print(k, t[k])
end
--&gt; 1	10
--&gt; 2	function: 0x560c95149d90
--&gt; 3	nil
--&gt; 4	4
</code></pre>
<p>需要注意带洞列表的长度：</p>
<pre><code class="language-lua">t = {10, x = 12, k = &quot;hi&quot;}
t[4] = &quot;4&quot;
for k = 1, #t do
print(k, t[k])
end
--&gt; 1	10
</code></pre>
<h3 id="安全导航"><a class="header" href="#安全导航">安全导航</a></h3>
<p>如果你需要索引一个很深的嵌套表，比如：</p>
<pre><code class="language-lua">zip = company and company.director and company.director.address and company.director.address.zipcode
</code></pre>
<p>那么这种做法是低效的，它需要对表做六次查询（看 <code>.</code> 的数量）。</p>
<p>在某些语言中（比如 C#），有 <code>?</code> 这个安全导航符号 (safe navigation operator)，这种情况可使用：</p>
<pre><code class="language-c#">zip = company?.director?.address?.zipcode
</code></pre>
<p>处理。但 lua 奉新极简主义，不打算提供这种语法。因为有绕行的办法：</p>
<pre><code class="language-lua">zip = (((company or {}).director or {}).address or {}).zipcode

-- 或者
E = {} -- 可在类似的表达式中重复使用
...
zip = (((company or E).director or E).address or E).zipcode
</code></pre>
<p>此时只需要做三次查询（已经是最小查询次数）。</p>
<h3 id="增删移动"><a class="header" href="#增删移动">增、删、移动</a></h3>
<p>针对序列的操作，即表（或者说列表）的 <code>{1, ..., n}</code> 索引的部分。</p>
<p>增 <code>table.insert</code>：</p>
<ul>
<li><code>table.insert(t, ele)</code> 等价于 <code>t[#t+1] = ele</code>，在序列的最后位置插入元素，即 <code>table.insert(t, #t, ele)</code></li>
<li><code>table.insert(t, pos, ele)</code>：在第 <code>pos</code> 位置上插入元素，它会把后面的元素往后移</li>
</ul>
<p>删 <code>table.remove</code>：</p>
<ul>
<li><code>table.remove(t)</code> 等价于 <code>last = t[#t]; t[#t] = nil; last</code>，它删除最后位置上的元素，并返回这个元素</li>
<li><code>table.remove(t, pos)</code>：删除第 <code>pos</code> 位置上的元素，并返回被删除的元素，它也会把之后的元素往前移</li>
</ul>
<p>有了这两个操作，lua 可以实现栈、队列、双向队列。虽然它们效率不高，但其背后是 C
的循环，在数百元素的情况下代价不算太昂贵。</p>
<p>移动 <code>table.move</code>：</p>
<ul>
<li>这是 lua5.3 引进的通用函数，对原表执行移动之后，返回新表的引用</li>
<li><code>table.move(a, f, e, p)</code> 表示把 a 表的 [f, e] 索引内的元素<strong>复制</strong>到位置 p 上</li>
<li><code>table.move(a, f, e, p, b)</code> 表示把 a 表的 [f, e] 索引内的元素<strong>复制</strong>到 b 表的位置 p 上</li>
<li><code>table.remove(t, pos)</code> 等价于 <code>table.move(t, pos+1, #t, pos); t[#t] = nil</code></li>
<li><code>table.insert(t, pos, ele)</code> 等价于 <code>table.move(t, pos, #t, pos+1); t[pos] = ele</code></li>
<li><code>table.move(a, 1, #a, 1, {})</code> 意味着返回 a 序列所有元素的副本序列</li>
<li><code>table.move(a, 1, #a, #b + 1, b)</code> 表示把 a 序列的所有元素添加到 b 序列之后</li>
</ul>
<p>完整的 <code>table</code> 操作请参考 <a href="https://www.lua.org/manual/5.3/manual.html#6.6">lua5.3-manual#Table Manipulation</a>：</p>
<ul>
<li><code>table.concat</code> 拼接序列的字符串和数字：如 <code>table.concat({&quot;a&quot;, 1}) == &quot;a&quot; .. 1 --&gt; &quot;a1&quot;</code></li>
<li><code>table.pack</code> 把多个表按照序列顺序存放到一个新表：如 <code>c = table.pack({a=1,b=2}, {1}); c[1].a == 1; c[2][1] == 1</code></li>
<li><code>table.unpack</code> 把一个表的序列部分拆分成多个元素：如 <code>d,e = table.unpack(c); d.a == 1; e[1] == 1</code></li>
<li><code>table.sort</code> 对一个表的序列排序（直接修改序列顺序）：如 <code>a = {1,3,2}; table.sort(a); table.concat(a) --&gt; &quot;123&quot;</code></li>
</ul>
<h2 id="function"><a class="header" href="#function"><code>function</code></a></h2>
<h3 id="基础要点-2"><a class="header" href="#基础要点-2">基础要点</a></h3>
<ul>
<li>调用函数的语法：
<ul>
<li>在有无参数的情况下，都使用括号：<code>os.date()</code>、<code>print(1, 2)</code></li>
<li>当参数只有一个，而且这个参数是字符串字面值或者表构造表达式，可以省略括号，也可以无需空格分隔：
<code>print&quot;1&quot;</code>、<code>type{} --&gt; table</code></li>
<li>方法调用：<code>o:foo(x)</code> 其中 <code>o</code> 是对象，<code>foo</code> 是其方法</li>
<li>调用来自 C 或者宿主应用 (host application) 的函数：#todo#</li>
</ul>
</li>
<li>参数：
<ul>
<li>
<p>可以输入与函数定义时数量不同的参数个数：</p>
<pre><code class="language-lua">function f (a, b) print(a, b) end

-- 以下都是有效调用
f() --&gt; nil nil
f(3) --&gt; 3 nil
f(3, 4) --&gt; 3 4
f(3, 4, 5) --&gt; 3 4 （5 被舍弃）
</code></pre>
</li>
<li>
<p>默认参数：</p>
<pre><code class="language-lua">-- 通过调用 `incCount()` 可以达到默认增加 1 的效果
function incCount (n)
  n = n or 1
  globalCounter = globalCounter + n
end
</code></pre>
</li>
<li>
<p>可变长度的参数：使用可变参数表达式 (vararg expression) <code>...</code> 作为函数参数，然后在函数内</p>
<ul>
<li>使用 <code>{...}</code> 把可变参数放入表</li>
<li>使用赋值语句获取所需数量的参数</li>
<li>使用 <code>select(i, ...)</code> 获取第 i 个及其之后的所有参数；或者使用 <code>select(&quot;#&quot;, ...)</code> 查看长度</li>
<li>使用 <code>table.pack(...)</code><sup class="footnote-reference"><a href="#pack">3</a></sup> 把可变参数放入表，并把长度记录到 <code>.n</code> 字段里</li>
<li><code>{...}</code> 的方式会忽略以 <code>nil</code> 结尾的那些参数，但 <code>select</code> 和 <code>table.pack</code> 不会</li>
</ul>
<pre><code class="language-lua">function add (...)
  local s = 0
  for _, v in ipairs{...} do
    s = s + v
  end
  local a = {...}     -- 还可以继续使用
  local _, b, c = ... -- 还可以继续使用
  print(a[1], b, c) 
  print(select(4, ...)) -- 还可以继续使用
  print(#a, select(&quot;#&quot;, ...), table.pack(...).n)
  return s
end
print(add(3, 4, 10, 25, 12)) --&gt; 54 （打印 3 4 10 和 25 12 和 5 5 5 ，返回 54）
print(add(3, 4, 10, 25, nil)) --&gt; 42 （打印 3 4 10 和 25 nil 和 4 5 5 ，返回 42）
</code></pre>
</li>
<li>
<p>可以混合固定参数和可变参数：如 <code>function f (a, b, ...) end</code></p>
</li>
</ul>
</li>
<li>返回值：
<ul>
<li>当函数作为语句被调用时，丢弃该函数所有返回值</li>
<li>当函数作为普通的表达式被调用时，只保留该函数的第一个返回值</li>
<li>当且仅当函数作为<strong>最后一个或者唯一一个</strong>表达式被调用时，才会得到这个函数的所有返回值。<br />
此时函数必须在以下表达式中出现：
<ul>
<li>多个赋值的表达式</li>
<li>另一个函数的参数</li>
<li><code>table</code> 的构造表达式</li>
<li><code>return</code> 语句里</li>
</ul>
</li>
<li>对于 <code>f(g())</code> 形式的函数调用，如果 <code>f()</code> 具有固定长度的参数，那么 <code>g()</code> 返回 <code>f()</code> 所需的固定长度的值</li>
<li>通过在函数调用的外围添加 <code>()</code> 来强制让该函数只返回一个值</li>
<li>返回值也可以是可变长度的：<code>function f (...) return ... end</code>、<code>function f (a, b, ...) return ... end</code></li>
<li>使用 <code>select(i, f())</code> 获取第 i 个及其之后的所有返回值；或者使用 <code>select(&quot;#&quot;, f())</code> 查看函数返回值的长度</li>
</ul>
</li>
</ul>
<div class="footnote-definition" id="pack"><sup class="footnote-definition-label">3</sup>
<p><code>table.pack</code> 函数是从 lua5.2 版本才引进的</p>
</div>
<pre><code class="language-lua">-- 返回值综合案例
function foo0 () end -- returns no results
function foo1 () return &quot;a&quot; end -- returns 1 result
function foo2 () return &quot;a&quot;, &quot;b&quot; end -- returns 2 results

x, y = foo2() -- x=&quot;a&quot;, y=&quot;b&quot;
x = foo2() -- x=&quot;a&quot;, &quot;b&quot; is discarded
x, y, z = 10, foo2() -- x=10, y=&quot;a&quot;, z=&quot;b&quot;

x,y = foo0() -- x=nil, y=nil
x,y = foo1() -- x=&quot;a&quot;, y=nil
x,y,z = foo2() -- x=&quot;a&quot;, y=&quot;b&quot;, z=nil

x,y = foo2(), 20 -- x=&quot;a&quot;, y=20 ('b' discarded)
x,y = foo0(), 20, 30 -- x=nil, y=20 (30 is discarded)

print(foo0()) --&gt; (no results)
print(foo1()) --&gt; a
print(foo2()) --&gt; a b
print(foo2(), 1) --&gt; a 1
print(foo2() .. &quot;x&quot;) --&gt; ax (这里不属于那四种表达式，是普通的表达式，所以只返回一个值)

t = {foo0()} -- t = {} (an empty table)
t = {foo1()} -- t = {&quot;a&quot;}
t = {foo2()} -- t = {&quot;a&quot;, &quot;b&quot;}

t = {foo0(), foo2(), 4} -- t[1] = nil, t[2] = &quot;a&quot;, t[3] = 4 这里并不是最后一个表达式

function foo (i)
  if i == 0 then return foo0()
    elseif i == 1 then return foo1()
    elseif i == 2 then return foo2()
  end
end

print(foo(1)) --&gt; a
print(foo(2)) --&gt; a b
print(foo(0)) -- (no results)
print(foo(3)) -- (no results)

print((foo0())) --&gt; nil
print((foo1())) --&gt; a
print((foo2())) --&gt; a
</code></pre>
<p><code>table.unpack</code> 进阶用法：</p>
<ul>
<li><code>table.unpack(t)</code> 把序列 <code>t</code> 一次分解成 [1, #t] 位置上的元素</li>
<li><code>table.unpack(t, start, end)</code> 把序列 <code>t</code> 一次分解成 [start, end] 位置上的元素</li>
<li>将其返回值放到函数参数上，形成变长和泛型调用
<pre><code class="language-lua">print(string.find(&quot;hello&quot;, &quot;ll&quot;))
-- 改成动态函数和动态参数的等价写法
f = string.find
a = {&quot;hello&quot;, &quot;ll&quot;}
print(f(table.unpack(a)))
</code></pre>
</li>
<li>该函数为 C 写成，其等价的 lua 写法：
<pre><code class="language-lua">function unpack (t, i, n)
  i = i or 1
  n = n or #t
  if i &lt;= n then
    return t[i], unpack(t, i + 1, n)
  end
end
</code></pre>
</li>
</ul>
<h3 id="尾调用"><a class="header" href="#尾调用">尾调用</a></h3>
<p>lua 的函数实现了尾调用消除 (tail-call elimination) —— 
当进行尾调用时，lua 不使用额外的栈空间，因为最后被调用的函数无需返回调用它的函数。</p>
<p>因此程序可以无限地嵌套尾调用，而不产生栈溢出。</p>
<p>但是要清楚尾调用的形式：<code>return func(args)</code> —— 即调用尾函数的函数，在调用尾函数之后，不做任何事情。</p>
<p>如下形式不是尾调用：</p>
<pre><code class="language-lua">function f (x) g(x) end         -- 无论 g 返回什么，f 都要返回
function f (x) return g(x) + 1  -- 执行了 g 还要执行加法操作
function f (x) return x or g(x) -- 需要把结果调整为 1 个
function f (x) return (g(x))    -- 需要把结果调整为 1 个
</code></pre>
<p>注意，<code>func</code> 和 <code>args</code> 可以是复杂的表达式，此时依然是尾调用，如 
<code>return x[i].foo(x[j] + a*b, i + j)</code>。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="Getting-Started.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="IO.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="Getting-Started.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="IO.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="theme/pagetoc.js"></script>
    </body>
</html>
